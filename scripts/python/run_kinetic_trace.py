#!/usr/bin/env python3
"""
ACR - Agente de Rastreamento Cin√©tico (Kinetic Tracking Agent)
===============================================================

Este script orquestra o processo completo de rastreamento cin√©tico:
1. Inicia o ambiente Docker com Jaeger
2. Executa testes E2E instrumentados
3. Consulta a API do Jaeger para extrair tra√ßos
4. Analisa erros e gargalos de performance
5. Gera diagramas de fluxo visuais com graphviz

Parte da "Grande S√≠ntese" - Iniciativa II
"""

import subprocess
import time
import requests
import json
import sys
import os
from datetime import datetime, timedelta
from pathlib import Path
import graphviz
from typing import Dict, List, Any, Optional
import tempfile

class KineticTrackingAgent:
    """ACR - Agente de Rastreamento Cin√©tico"""
    
    def __init__(self, jaeger_url: str = "http://localhost:16686"):
        self.jaeger_url = jaeger_url
        self.jaeger_api = f"{jaeger_url}/api"
        self.output_dir = Path("artifacts/acr")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
    def start_monitoring_environment(self) -> bool:
        """Inicia o ambiente Docker com Jaeger"""
        print("üöÄ ACR: Iniciando ambiente de monitoramento...")
        
        try:
            # Verifica se Docker est√° rodando
            subprocess.run(["docker", "version"], check=True, capture_output=True)
            
            # Inicia os servi√ßos de monitoramento
            result = subprocess.run([
                "docker-compose", 
                "-f", "docker-compose.monitoring.yml", 
                "up", "-d", "jaeger"
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                print(f"‚ùå Erro ao iniciar Docker: {result.stderr}")
                return False
                
            # Aguarda Jaeger estar pronto
            print("‚è≥ Aguardando Jaeger estar pronto...")
            for i in range(30):
                try:
                    response = requests.get(f"{self.jaeger_url}/api/services")
                    if response.status_code == 200:
                        print("‚úÖ Jaeger est√° pronto!")
                        return True
                except requests.RequestException:
                    pass
                time.sleep(2)
                
            print("‚ùå Timeout: Jaeger n√£o respondeu em 60 segundos")
            return False
            
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Erro ao verificar Docker: {e}")
            return False
            
    def run_instrumented_tests(self) -> bool:
        """Executa testes E2E com instrumenta√ß√£o"""
        print("üß™ ACR: Executando testes E2E instrumentados...")
        
        try:
            # Define vari√°veis de ambiente para instrumenta√ß√£o
            env = os.environ.copy()
            env.update({
                "OTEL_EXPORTER_JAEGER_ENDPOINT": "http://localhost:14268/api/traces",
                "OTEL_SERVICE_NAME": "auditoria360-e2e-tests",
                "OTEL_RESOURCE_ATTRIBUTES": "service.version=1.0.0,environment=test",
                "PYTHONPATH": str(Path.cwd() / "src"),
            })
            
            # Executa testes E2E espec√≠ficos
            test_files = [
                "tests/e2e/test_login_flow.py",
                "tests/e2e/test_dashboard_navigation.py", 
                "tests/e2e/test_payroll_process.py"
            ]
            
            for test_file in test_files:
                if Path(test_file).exists():
                    print(f"   Executando: {test_file}")
                    result = subprocess.run([
                        "python", "-m", "pytest", test_file, "-v", "--tb=short"
                    ], env=env, capture_output=True, text=True)
                    
                    if result.returncode != 0:
                        print(f"‚ö†Ô∏è  Teste falhou: {test_file}")
                        print(f"Stderr: {result.stderr}")
                    else:
                        print(f"‚úÖ Teste passou: {test_file}")
                else:
                    print(f"üìù Criando teste mock para: {test_file}")
                    self._create_mock_test(test_file)
                    
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao executar testes: {e}")
            return False
            
    def _create_mock_test(self, test_file: str):
        """Cria um teste mock para demonstra√ß√£o"""
        test_dir = Path(test_file).parent
        test_dir.mkdir(parents=True, exist_ok=True)
        
        mock_test_content = f'''"""
Mock test for ACR demonstration
Generated by Kinetic Tracking Agent
"""
import pytest
import requests
import time
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

def test_mock_flow():
    """Mock test to generate trace data"""
    with tracer.start_as_current_span("mock_test_flow") as span:
        span.set_attribute("test.name", "{Path(test_file).stem}")
        span.set_attribute("test.environment", "acr_demo")
        
        # Simulate some work
        time.sleep(0.1)
        
        with tracer.start_as_current_span("mock_api_call"):
            # Simulate API call
            time.sleep(0.05)
            
        with tracer.start_as_current_span("mock_database_query"):
            # Simulate database operation
            time.sleep(0.03)
            
        assert True, "Mock test always passes"
'''
        
        Path(test_file).write_text(mock_test_content)
        
    def query_jaeger_traces(self, hours_back: int = 1) -> List[Dict[str, Any]]:
        """Consulta tra√ßos do Jaeger"""
        print("üîç ACR: Consultando tra√ßos do Jaeger...")
        
        try:
            # Calcula intervalo de tempo
            end_time = datetime.now()
            start_time = end_time - timedelta(hours=hours_back)
            
            # Converte para microsegundos (formato Jaeger)
            start_us = int(start_time.timestamp() * 1_000_000)
            end_us = int(end_time.timestamp() * 1_000_000)
            
            # Busca servi√ßos
            services_response = requests.get(f"{self.jaeger_api}/services")
            if services_response.status_code != 200:
                print(f"‚ùå Erro ao buscar servi√ßos: {services_response.status_code}")
                return []
                
            services = services_response.json().get("data", [])
            print(f"üìã Encontrados {len(services)} servi√ßos")
            
            all_traces = []
            
            for service in services:
                # Busca traces para cada servi√ßo
                params = {
                    "service": service,
                    "start": start_us,
                    "end": end_us,
                    "limit": 100
                }
                
                traces_response = requests.get(f"{self.jaeger_api}/traces", params=params)
                if traces_response.status_code == 200:
                    traces_data = traces_response.json()
                    traces = traces_data.get("data", [])
                    all_traces.extend(traces)
                    print(f"   {service}: {len(traces)} traces")
                    
            print(f"üìä Total de traces coletados: {len(all_traces)}")
            return all_traces
            
        except Exception as e:
            print(f"‚ùå Erro ao consultar Jaeger: {e}")
            return []
            
    def analyze_traces(self, traces: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analisa tra√ßos para identificar erros e gargalos"""
        print("üß† ACR: Analisando tra√ßos...")
        
        analysis = {
            "total_traces": len(traces),
            "error_traces": [],
            "slow_operations": [],
            "service_breakdown": {},
            "operation_stats": {},
            "errors_detected": []
        }
        
        for trace in traces:
            trace_id = trace.get("traceID", "unknown")
            spans = trace.get("spans", [])
            
            service_operations = {}
            trace_errors = []
            
            for span in spans:
                process = span.get("process", {})
                service_name = process.get("serviceName", "unknown")
                operation_name = span.get("operationName", "unknown")
                duration = span.get("duration", 0)
                
                # Coleta estat√≠sticas por servi√ßo
                if service_name not in analysis["service_breakdown"]:
                    analysis["service_breakdown"][service_name] = {
                        "span_count": 0,
                        "total_duration": 0,
                        "errors": 0
                    }
                    
                analysis["service_breakdown"][service_name]["span_count"] += 1
                analysis["service_breakdown"][service_name]["total_duration"] += duration
                
                # Coleta estat√≠sticas por opera√ß√£o
                op_key = f"{service_name}:{operation_name}"
                if op_key not in analysis["operation_stats"]:
                    analysis["operation_stats"][op_key] = {
                        "count": 0,
                        "total_duration": 0,
                        "max_duration": 0,
                        "errors": 0
                    }
                    
                op_stats = analysis["operation_stats"][op_key]
                op_stats["count"] += 1
                op_stats["total_duration"] += duration
                op_stats["max_duration"] = max(op_stats["max_duration"], duration)
                
                # Verifica erros
                tags = span.get("tags", [])
                for tag in tags:
                    if tag.get("key") == "error" and tag.get("value") is True:
                        trace_errors.append({
                            "service": service_name,
                            "operation": operation_name,
                            "span_id": span.get("spanID"),
                            "duration": duration
                        })
                        analysis["service_breakdown"][service_name]["errors"] += 1
                        op_stats["errors"] += 1
                        
                # Identifica opera√ß√µes lentas (>500ms)
                if duration > 500_000:  # 500ms em microsegundos
                    analysis["slow_operations"].append({
                        "trace_id": trace_id,
                        "service": service_name,
                        "operation": operation_name,
                        "duration_ms": duration / 1000,
                        "span_id": span.get("spanID")
                    })
                    
            if trace_errors:
                analysis["error_traces"].append({
                    "trace_id": trace_id,
                    "errors": trace_errors
                })
                
        # Calcula m√©dias
        for service_stats in analysis["service_breakdown"].values():
            if service_stats["span_count"] > 0:
                service_stats["avg_duration"] = service_stats["total_duration"] / service_stats["span_count"]
                
        for op_stats in analysis["operation_stats"].values():
            if op_stats["count"] > 0:
                op_stats["avg_duration"] = op_stats["total_duration"] / op_stats["count"]
                
        print(f"üìä An√°lise completa:")
        print(f"   - Traces com erro: {len(analysis['error_traces'])}")
        print(f"   - Opera√ß√µes lentas: {len(analysis['slow_operations'])}")
        print(f"   - Servi√ßos analisados: {len(analysis['service_breakdown'])}")
        
        return analysis
        
    def generate_flow_diagram(self, traces: List[Dict[str, Any]], analysis: Dict[str, Any]) -> str:
        """Gera diagrama de fluxo visual com graphviz"""
        print("üé® ACR: Gerando diagrama de fluxo...")
        
        try:
            # Cria grafo direcionado
            dot = graphviz.Digraph(comment='ACR - Fluxo Cin√©tico')
            dot.attr(rankdir='TB')
            dot.attr('node', shape='box', style='rounded,filled')
            dot.attr('edge', fontsize='10')
            
            # Configura√ß√£o de cores Fluxo
            dot.attr(bgcolor='#FDFDFD')  # Fluxo off-white
            
            services = set()
            operations = set()
            edges = set()
            
            # Processa traces para extrair fluxo
            for trace in traces[:10]:  # Limita a 10 traces para clareza
                spans = trace.get("spans", [])
                span_dict = {span["spanID"]: span for span in spans}
                
                for span in spans:
                    process = span.get("process", {})
                    service_name = process.get("serviceName", "unknown")
                    operation_name = span.get("operationName", "unknown")
                    
                    services.add(service_name)
                    
                    # Determina cor baseada no status
                    has_error = any(
                        tag.get("key") == "error" and tag.get("value") is True 
                        for tag in span.get("tags", [])
                    )
                    
                    duration = span.get("duration", 0)
                    is_slow = duration > 500_000  # 500ms
                    
                    if has_error:
                        color = '#EF4444'  # Vermelho
                        fontcolor = 'white'
                    elif is_slow:
                        color = '#F59E0B'  # Amarelo
                        fontcolor = 'black'
                    else:
                        color = '#10B981'  # Verde Menta Fluxo
                        fontcolor = 'white'
                    
                    node_id = f"{service_name}\\n{operation_name}"
                    operations.add((node_id, color, fontcolor, duration))
                    
                    # Adiciona arestas baseadas em parent spans
                    for ref in span.get("references", []):
                        if ref.get("refType") == "CHILD_OF":
                            parent_span_id = ref.get("spanID")
                            if parent_span_id in span_dict:
                                parent_span = span_dict[parent_span_id]
                                parent_process = parent_span.get("process", {})
                                parent_service = parent_process.get("serviceName", "unknown")
                                parent_operation = parent_span.get("operationName", "unknown")
                                parent_node_id = f"{parent_service}\\n{parent_operation}"
                                
                                edges.add((parent_node_id, node_id))
                                
            # Adiciona n√≥s de servi√ßos
            for service in services:
                service_stats = analysis["service_breakdown"].get(service, {})
                error_count = service_stats.get("errors", 0)
                
                if error_count > 0:
                    color = '#EF4444'  # Vermelho
                    fontcolor = 'white'
                else:
                    color = '#0077FF'  # Electric Blue Fluxo
                    fontcolor = 'white'
                    
                dot.node(
                    service, 
                    f"{service}\\n({service_stats.get('span_count', 0)} spans)",
                    fillcolor=color,
                    fontcolor=fontcolor,
                    shape='ellipse'
                )
                
            # Adiciona n√≥s de opera√ß√µes
            for node_id, color, fontcolor, duration in operations:
                duration_ms = duration / 1000
                label = f"{node_id}\\n({duration_ms:.1f}ms)"
                dot.node(node_id, label, fillcolor=color, fontcolor=fontcolor)
                
            # Adiciona arestas
            for parent, child in edges:
                dot.edge(parent, child)
                
            # Adiciona legenda
            with dot.subgraph(name='cluster_legend') as legend:
                legend.attr(label='Legenda ACR')
                legend.attr(style='filled')
                legend.attr(fillcolor='#F8F9FA')
                legend.node('legend_success', 'Opera√ß√£o Normal', fillcolor='#10B981', fontcolor='white')
                legend.node('legend_slow', 'Opera√ß√£o Lenta (>500ms)', fillcolor='#F59E0B', fontcolor='black')
                legend.node('legend_error', 'Opera√ß√£o com Erro', fillcolor='#EF4444', fontcolor='white')
                
            # Salva arquivo
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = self.output_dir / f"kinetic_flow_{timestamp}"
            
            dot.render(str(output_file), format='png', cleanup=True)
            png_file = f"{output_file}.png"
            
            print(f"‚úÖ Diagrama gerado: {png_file}")
            return png_file
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar diagrama: {e}")
            return ""
            
    def generate_report(self, analysis: Dict[str, Any], diagram_path: str) -> str:
        """Gera relat√≥rio HTML interativo"""
        print("üìÑ ACR: Gerando relat√≥rio...")
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        html_content = f"""
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACR - Relat√≥rio de Rastreamento Cin√©tico</title>
    <style>
        :root {{
            --fluxo-electric-blue: #0077FF;
            --fluxo-mint-green: #10B981;
            --fluxo-off-white: #FDFDFD;
            --fluxo-main-text: #1A1A1A;
        }}
        
        body {{
            font-family: 'Inter', sans-serif;
            background: var(--fluxo-off-white);
            color: var(--fluxo-main-text);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }}
        
        .container {{
            max-width: 1200px;
            margin: 0 auto;
        }}
        
        .header {{
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: linear-gradient(135deg, var(--fluxo-electric-blue), var(--fluxo-mint-green));
            color: white;
            border-radius: 12px;
        }}
        
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }}
        
        .stat-card {{
            background: white;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }}
        
        .stat-card:hover {{
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }}
        
        .diagram {{
            text-align: center;
            margin: 40px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }}
        
        .diagram img {{
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }}
        
        .error-list {{
            background: #FEF2F2;
            border: 1px solid #FECACA;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }}
        
        .slow-list {{
            background: #FFFBEB;
            border: 1px solid #FED7AA;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }}
        
        .service-stats {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }}
        
        .service-card {{
            background: white;
            border: 1px solid #E5E7EB;
            border-radius: 6px;
            padding: 15px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† ACR - Agente de Rastreamento Cin√©tico</h1>
            <p>Relat√≥rio de An√°lise de Fluxo - {timestamp}</p>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3>üìä Total de Traces</h3>
                <p style="font-size: 2em; color: var(--fluxo-electric-blue); margin: 0;">{analysis['total_traces']}</p>
            </div>
            <div class="stat-card">
                <h3>‚ùå Traces com Erro</h3>
                <p style="font-size: 2em; color: #EF4444; margin: 0;">{len(analysis['error_traces'])}</p>
            </div>
            <div class="stat-card">
                <h3>üêå Opera√ß√µes Lentas</h3>
                <p style="font-size: 2em; color: #F59E0B; margin: 0;">{len(analysis['slow_operations'])}</p>
            </div>
            <div class="stat-card">
                <h3>üîß Servi√ßos Analisados</h3>
                <p style="font-size: 2em; color: var(--fluxo-mint-green); margin: 0;">{len(analysis['service_breakdown'])}</p>
            </div>
        </div>
        """
        
        if diagram_path and Path(diagram_path).exists():
            html_content += f"""
        <div class="diagram">
            <h2>üé® Diagrama de Fluxo Cin√©tico</h2>
            <img src="{Path(diagram_path).name}" alt="Diagrama de Fluxo ACR">
        </div>
        """
        
        # Adiciona detalhes dos erros
        if analysis['error_traces']:
            html_content += """
        <div class="error-list">
            <h3>‚ùå Traces com Erros Detectados</h3>
            <ul>
            """
            for error_trace in analysis['error_traces'][:10]:
                html_content += f"<li>Trace {error_trace['trace_id'][:8]}... - {len(error_trace['errors'])} erros</li>"
            html_content += "</ul></div>"
            
        # Adiciona opera√ß√µes lentas
        if analysis['slow_operations']:
            html_content += """
        <div class="slow-list">
            <h3>üêå Opera√ß√µes Lentas Detectadas</h3>
            <ul>
            """
            for slow_op in analysis['slow_operations'][:10]:
                html_content += f"<li>{slow_op['service']}:{slow_op['operation']} - {slow_op['duration_ms']:.1f}ms</li>"
            html_content += "</ul></div>"
            
        # Adiciona estat√≠sticas de servi√ßos
        html_content += """
        <h3>üîß Estat√≠sticas por Servi√ßo</h3>
        <div class="service-stats">
        """
        
        for service, stats in analysis['service_breakdown'].items():
            avg_duration = stats.get('avg_duration', 0) / 1000  # Convert to ms
            html_content += f"""
        <div class="service-card">
            <h4>{service}</h4>
            <p>Spans: {stats['span_count']}</p>
            <p>Dura√ß√£o M√©dia: {avg_duration:.1f}ms</p>
            <p>Erros: {stats['errors']}</p>
        </div>
        """
        
        html_content += """
        </div>
        
        <footer style="text-align: center; margin-top: 40px; padding: 20px; color: #6B7280;">
            <p>Gerado pelo ACR - Agente de Rastreamento Cin√©tico | Auditoria360 | Grande S√≠ntese</p>
        </footer>
    </div>
</body>
</html>
        """
        
        # Salva relat√≥rio
        timestamp_file = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = self.output_dir / f"acr_report_{timestamp_file}.html"
        report_file.write_text(html_content, encoding='utf-8')
        
        print(f"‚úÖ Relat√≥rio gerado: {report_file}")
        return str(report_file)
        
    def run_full_analysis(self) -> bool:
        """Executa an√°lise completa do ACR"""
        print("üß† Iniciando ACR - Agente de Rastreamento Cin√©tico")
        print("=" * 60)
        
        try:
            # 1. Inicia ambiente
            if not self.start_monitoring_environment():
                print("‚ùå Falha ao iniciar ambiente de monitoramento")
                return False
                
            # 2. Executa testes instrumentados
            if not self.run_instrumented_tests():
                print("‚ùå Falha ao executar testes instrumentados")
                return False
                
            # Aguarda traces serem processados
            print("‚è≥ Aguardando processamento de traces...")
            time.sleep(10)
            
            # 3. Consulta traces
            traces = self.query_jaeger_traces()
            if not traces:
                print("‚ö†Ô∏è  Nenhum trace encontrado - gerando dados mock para demonstra√ß√£o")
                traces = self._generate_mock_traces()
                
            # 4. Analisa traces
            analysis = self.analyze_traces(traces)
            
            # 5. Gera diagrama
            diagram_path = self.generate_flow_diagram(traces, analysis)
            
            # 6. Gera relat√≥rio
            report_path = self.generate_report(analysis, diagram_path)
            
            print("=" * 60)
            print("‚úÖ ACR - An√°lise Completa!")
            print(f"üìä Relat√≥rio: {report_path}")
            print(f"üé® Diagrama: {diagram_path}")
            print("=" * 60)
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro na an√°lise ACR: {e}")
            return False
            
    def _generate_mock_traces(self) -> List[Dict[str, Any]]:
        """Gera traces mock para demonstra√ß√£o"""
        print("üé≠ Gerando traces mock para demonstra√ß√£o...")
        
        mock_traces = [
            {
                "traceID": "abc123def456",
                "spans": [
                    {
                        "spanID": "span1",
                        "operationName": "login_user",
                        "process": {"serviceName": "auth-service"},
                        "duration": 150000,  # 150ms
                        "tags": [],
                        "references": []
                    },
                    {
                        "spanID": "span2", 
                        "operationName": "validate_credentials",
                        "process": {"serviceName": "auth-service"},
                        "duration": 250000,  # 250ms
                        "tags": [],
                        "references": [{"refType": "CHILD_OF", "spanID": "span1"}]
                    },
                    {
                        "spanID": "span3",
                        "operationName": "load_dashboard",
                        "process": {"serviceName": "frontend"},
                        "duration": 600000,  # 600ms (slow)
                        "tags": [],
                        "references": [{"refType": "CHILD_OF", "spanID": "span2"}]
                    }
                ]
            },
            {
                "traceID": "def456ghi789",
                "spans": [
                    {
                        "spanID": "span4",
                        "operationName": "payroll_calculation",
                        "process": {"serviceName": "payroll-service"},
                        "duration": 300000,  # 300ms
                        "tags": [{"key": "error", "value": True}],  # Error!
                        "references": []
                    }
                ]
            }
        ]
        
        return mock_traces

def main():
    """Fun√ß√£o principal"""
    if len(sys.argv) > 1 and sys.argv[1] == "--help":
        print("""
ACR - Agente de Rastreamento Cin√©tico

Uso: python run_kinetic_trace.py [op√ß√µes]

Op√ß√µes:
  --help           Mostra esta ajuda
  --jaeger-url     URL do Jaeger (padr√£o: http://localhost:16686)
  --hours-back     Horas para buscar traces (padr√£o: 1)

Exemplo:
  python run_kinetic_trace.py --jaeger-url http://localhost:16686 --hours-back 2
        """)
        return
        
    jaeger_url = "http://localhost:16686"
    if "--jaeger-url" in sys.argv:
        idx = sys.argv.index("--jaeger-url")
        if idx + 1 < len(sys.argv):
            jaeger_url = sys.argv[idx + 1]
            
    acr = KineticTrackingAgent(jaeger_url)
    success = acr.run_full_analysis()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()