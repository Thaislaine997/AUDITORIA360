import streamlit as st
import sys # Add sys
import os # Add os

# --- Path Setup ---
_project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..')) # Adjusted for pages subdir
if _project_root not in sys.path:
    sys.path.insert(0, _project_root)
# --- End Path Setup ---

import requests
from datetime import date
import pandas as pd

from src.core.config import settings
# Ajustar import para usar os utilit√°rios globais de forma consistente
from src.frontend.utils import (
    display_user_info_sidebar as global_display_user_info_sidebar, 
    handle_api_error, 
    get_api_token as get_global_api_token, 
    get_current_client_id as get_global_current_client_id, # Mantido para consist√™ncia, embora possa n√£o ser usado diretamente
    get_auth_headers as get_global_auth_headers # Importar get_auth_headers global
)
from src.core.log_utils import logger # Adicionar import do logger

# Fun√ß√µes wrapper locais para consist√™ncia
def get_api_token() -> str | None:
    return get_global_api_token()

def get_current_client_id() -> str | None: # Admin pode n√£o operar no contexto de um cliente espec√≠fico
    return get_global_current_client_id()

def display_user_info_sidebar():
    global_display_user_info_sidebar()

def get_auth_headers_admin_params(): # Wrapper local para headers
    token = get_api_token()
    return get_global_auth_headers(token) # Chama o global com o token

def mostrar_pagina_admin_parametros_legais():
    st.set_page_config(page_title="Administra√ß√£o de Par√¢metros Legais - AUDITORIA360", layout="wide") # Nome da p√°gina atualizado
    
    # --- Logo --- (Removido, display_user_info_sidebar cuida disso)
    # st.sidebar.markdown(\"---\") # Removido

    api_token = get_api_token()
    # id_cliente_atual = get_current_client_id() # Removido ou comentado, pois admin pode n√£o ter cliente espec√≠fico

    # Verifica√ß√£o de autentica√ß√£o
    if not api_token: 
        st.warning("Acesso restrito. Por favor, fa√ßa login com uma conta administrativa.")
        if st.button("Retornar ao Login"):
            try:
                st.switch_page("painel.py")
            except AttributeError:
                st.page_link("painel.py", label="Retornar ao Login", icon="üè†")
            except Exception as e:
                 st.page_link("painel.py", label="Retornar ao Login", icon="üè†")
                 logger.warning(f"Falha ao usar st.switch_page para painel.py: {e}, usando page_link.")
        st.stop()
    
    # Adicionar verifica√ß√£o de perfil/role se dispon√≠vel em st.session_state.user_info
    user_info = st.session_state.get("user_info", {})
    user_roles = user_info.get("roles", []) # Supondo que 'roles' seja uma lista de strings
    # Idealmente, o backend protegeria essas rotas, mas uma verifica√ß√£o no frontend √© uma boa pr√°tica adicional.
    # if "admin" not in user_roles: # Descomentar e ajustar se a role 'admin' for usada
    #     st.error("Voc√™ n√£o tem permiss√£o para acessar esta p√°gina. Contate o administrador.")
    #     logger.warning(f"Usu√°rio {user_info.get(\'username\', \'desconhecido\')} sem role \'admin\' tentou acessar Admin Par√¢metros.")
    #     st.stop()

    display_user_info_sidebar()

    st.title("‚öôÔ∏è Administra√ß√£o de Par√¢metros Legais")
    st.caption("Gest√£o de tabelas de INSS, IRRF, Sal√°rio Fam√≠lia, Sal√°rio M√≠nimo, FGTS e outros.")
    # st.caption(f"Cliente ID: {id_cliente_atual}") # Removido ou comentado

    PARAMETROS_CONFIG = {
        "INSS": {"endpoint": "inss", "form_fields": {"id_parametro_inss": "ID (Opcional, deixe em branco para auto)", "data_inicio_vigencia": "Data In√≠cio Vig√™ncia", "faixa_salarial_de": "Faixa Salarial De (R$)", "faixa_salarial_ate": "Faixa Salarial At√© (R$)", "aliquota_efetiva_percentual": "Al√≠quota Efetiva (%)", "parcela_a_deduzir": "Parcela a Deduzir (R$)", "descricao": "Descri√ß√£o (Opcional)"}, "list_columns": ["id_parametro_inss", "data_inicio_vigencia", "faixa_salarial_de", "faixa_salarial_ate", "aliquota_efetiva_percentual", "parcela_a_deduzir", "descricao"]},
        "IRRF": {"endpoint": "irrf", "form_fields": {"id_parametro_irrf": "ID (Opcional)", "data_inicio_vigencia": "Data In√≠cio Vig√™ncia", "base_calculo_de": "Base C√°lculo De (R$)", "base_calculo_ate": "Base C√°lculo At√© (R$)", "aliquota_percentual": "Al√≠quota (%)", "parcela_a_deduzir_imposto": "Parcela a Deduzir (R$)", "limite_deducao_simplificada": "Limite Dedu√ß√£o Simplificada (R$)", "descricao": "Descri√ß√£o (Opcional)"}, "list_columns": ["id_parametro_irrf", "data_inicio_vigencia", "base_calculo_de", "base_calculo_ate", "aliquota_percentual", "parcela_a_deduzir_imposto", "limite_deducao_simplificada", "descricao"]},
        "Sal√°rio Fam√≠lia": {"endpoint": "salario-familia", "form_fields": {"id_parametro_salario_familia": "ID (Opcional)", "data_inicio_vigencia": "Data In√≠cio Vig√™ncia", "remuneracao_mensal_ate": "Remunera√ß√£o Mensal At√© (R$)", "valor_quota_por_filho": "Valor da Quota (R$)", "descricao": "Descri√ß√£o (Opcional)"}, "list_columns": ["id_parametro_salario_familia", "data_inicio_vigencia", "remuneracao_mensal_ate", "valor_quota_por_filho", "descricao"]},
        "Sal√°rio M√≠nimo": {"endpoint": "salario-minimo", "form_fields": {"id_parametro_salario_minimo": "ID (Opcional)", "data_inicio_vigencia": "Data In√≠cio Vig√™ncia", "valor_mensal": "Valor Mensal (R$)", "valor_diario": "Valor Di√°rio (R$)", "valor_hora": "Valor Hora (R$)", "norma_legal_referencia": "Norma Legal (Opcional)", "regiao_geografica_aplicavel": "Regi√£o (Opcional, ex: Nacional, SP, RJ)"}, "list_columns": ["id_parametro_salario_minimo", "data_inicio_vigencia", "valor_mensal", "valor_diario", "valor_hora", "norma_legal_referencia", "regiao_geografica_aplicavel"]},
        "FGTS": {"endpoint": "fgts", "form_fields": {"id_parametro_fgts": "ID (Opcional)", "data_inicio_vigencia": "Data In√≠cio Vig√™ncia", "percentual_aliquota_normal": "Al√≠quota Normal (%)", "percentual_aliquota_contrato_verde_amarelo": "Al√≠quota Contrato Verde/Amarelo (%)", "percentual_aliquota_menor_aprendiz": "Al√≠quota Menor Aprendiz (%)", "descricao": "Descri√ß√£o (Opcional)"}, "list_columns": ["id_parametro_fgts", "data_inicio_vigencia", "percentual_aliquota_normal", "percentual_aliquota_contrato_verde_amarelo", "percentual_aliquota_menor_aprendiz", "descricao"]}
        # Adicionar outros par√¢metros como "Outros Par√¢metros Legais" se houver um endpoint gen√©rico
    }

    aba_selecionada = st.selectbox("Escolha o par√¢metro para gerenciar:", list(PARAMETROS_CONFIG.keys()), key="sel_param_legal")

    if aba_selecionada:
        config = PARAMETROS_CONFIG[aba_selecionada]
        endpoint_url = f"{settings.API_BASE_URL}/api/v1/parametros-legais-admin/{config['endpoint']}"
        headers = get_auth_headers_admin_params() # Usar a fun√ß√£o wrapper

        st.header(f"Hist√≥rico de Par√¢metros {aba_selecionada}")
        
        # Bot√£o para Listar/Atualizar
        if st.button(f"Listar/Atualizar Par√¢metros {aba_selecionada}", key=f"btn_list_{config['endpoint']}"):
            st.session_state[f"data_{config['endpoint']}"] = None # For√ßar recarga

        # Carregar e exibir dados
        if f"data_{config['endpoint']}" not in st.session_state or st.session_state[f"data_{config['endpoint']}"] is None:
            try:
                logger.info(f"Buscando par√¢metros para {aba_selecionada} em {endpoint_url}") # Logger
                r = requests.get(endpoint_url, headers=headers)
                if r.status_code == 401:
                    handle_api_error(r.status_code) # Chama o handler global
                    st.rerun()
                    return 
                r.raise_for_status()
                st.session_state[f"data_{config['endpoint']}"] = r.json()
            except requests.exceptions.HTTPError as http_err: # Tratamento de erro HTTP mais espec√≠fico
                logger.error(f"Erro HTTP ao buscar par√¢metros {aba_selecionada}: {http_err.response.status_code} - {http_err.response.text}")
                error_detail = http_err.response.text
                try:
                    error_detail = http_err.response.json().get("detail", error_detail)
                except ValueError: # json.JSONDecodeError √© um subtipo de ValueError
                    pass
                st.error(f"Erro ao buscar par√¢metros {aba_selecionada} (HTTP {http_err.response.status_code}): {error_detail}")
                st.session_state[f"data_{config['endpoint']}"] = []
            except requests.exceptions.RequestException as e:
                logger.error(f"Erro de conex√£o ao buscar par√¢metros {aba_selecionada}: {e}", exc_info=True)
                st.error(f"Erro de conex√£o ao buscar par√¢metros {aba_selecionada}: {e}")
                st.session_state[f"data_{config['endpoint']}"] = []
            except ValueError: # Tratar JSONDecodeError
                logger.error(f"Erro ao decodificar JSON da busca de par√¢metros {aba_selecionada}: {r.text if 'r' in locals() else 'Resposta n√£o dispon√≠vel'}")
                st.error(f"Erro ao processar a resposta do servidor (par√¢metros {aba_selecionada}).")
                st.session_state[f"data_{config['endpoint']}"] = []
            except Exception as e: # Captura gen√©rica
                logger.error(f"Erro inesperado ao processar par√¢metros {aba_selecionada}: {e}", exc_info=True)
                st.error(f"Erro inesperado ao processar par√¢metros {aba_selecionada}: {e}")
                st.session_state[f"data_{config['endpoint']}"] = []
        
        data_to_display = st.session_state.get(f"data_{config['endpoint']}", [])
        if data_to_display:
            df = pd.DataFrame(data_to_display)
            # Garantir que todas as colunas esperadas existam no DataFrame, preenchendo com None se faltarem
            for col_name in config["list_columns"]:
                if col_name not in df.columns:
                    df[col_name] = None
            st.dataframe(df[config["list_columns"]], use_container_width=True, hide_index=True)
        else:
            st.info(f"Nenhum par√¢metro {aba_selecionada} encontrado ou erro ao carregar.")

        st.subheader(f"Adicionar/Editar Par√¢metro {aba_selecionada}")
        # Usar um ID de formul√°rio din√¢mico para evitar conflitos entre abas se fossem renderizadas simultaneamente
        with st.form(f"form_novo_{config['endpoint']}", clear_on_submit=True):
            payload = {}
            # Campo para ID (para edi√ß√£o) - opcionalmente escondido ou apenas para refer√™ncia
            param_id_for_edit = st.text_input("ID do Par√¢metro para Editar (deixe em branco para criar novo)", key=f"id_edit_{config['endpoint']}")
            
            for field, label in config["form_fields"].items():
                if "data_inicio_vigencia" in field:
                    payload[field] = st.date_input(label, value=date.today(), key=f"{config['endpoint']}_{field}")
                elif any(keyword in field for keyword in ["percentual", "aliquota", "valor", "parcela", "faixa", "base_calculo", "limite"]):
                     # Tentar converter para float, mas manter como string se falhar ou se for uma faixa complexa
                    payload[field] = st.number_input(label, value=None, format="%.2f", key=f"{config['endpoint']}_{field}")
                else:
                    payload[field] = st.text_input(label, key=f"{config['endpoint']}_{field}")
            
            submitted = st.form_submit_button("Salvar Par√¢metro")
            if submitted:
                # Converter datas para string ISO format
                for key, value in payload.items():
                    if isinstance(value, date):
                        payload[key] = value.isoformat()
                
                # Remover campos vazios do payload, exceto aqueles que podem ser intencionalmente None/null (ex: data_fim_vigencia)
                # A API deve tratar campos opcionais n√£o enviados.
                final_payload = {k: v for k, v in payload.items() if v is not None and v != ""}
                
                # L√≥gica para POST (criar) ou PUT (atualizar)
                request_method = requests.post
                url_to_call = endpoint_url
                success_message = f"Par√¢metro {aba_selecionada} salvo com sucesso!"

                if param_id_for_edit: # Se um ID foi fornecido, tentamos um PUT
                    # A API deve aceitar o ID no corpo ou no path. Se for no path:
                    url_to_call = f"{endpoint_url}/{param_id_for_edit}"
                    request_method = requests.put
                    # Remover o ID do payload se ele estiver no path e n√£o for esperado no corpo do PUT
                    # if config["form_fields"].keys()[0] in final_payload: # Ex: id_parametro_inss
                    #    del final_payload[config["form_fields"].keys()[0]] 
                    # A linha acima √© um exemplo, a l√≥gica exata depende da API.
                    # Se o ID principal (ex: id_parametro_inss) est√° no payload e √© usado para identificar o registro no PUT, mantenha-o.
                    # Se o ID √© apenas para o path, e o payload √© o restante dos dados, ajuste.
                    # Por simplicidade, vamos assumir que o ID pode estar no payload para PUT tamb√©m, ou a API o ignora se estiver no path.

                try:
                    logger.info(f"Salvando par√¢metro {aba_selecionada}. M√©todo: {'PUT' if param_id_for_edit else 'POST'}, URL: {url_to_call}, Payload: {final_payload}") # Logger
                    r = request_method(url_to_call, json=final_payload, headers=headers)
                    if r.status_code == 401:
                        handle_api_error(r.status_code)
                        st.rerun() 
                        # N√£o retorna para exibir erro no form
                    elif r.status_code in [200, 201]: 
                        st.success(success_message)
                        logger.info(success_message) # Logger
                        st.session_state[f"data_{config['endpoint']}"] = None 
                        st.rerun()
                    else:
                        error_text = r.text
                        try:
                            error_text = r.json().get("detail", error_text)
                        except ValueError:
                            pass
                        st.error(f"Erro ao salvar par√¢metro {aba_selecionada} (C√≥d: {r.status_code}): {error_text}")
                        logger.error(f"Erro HTTP ao salvar par√¢metro {aba_selecionada} ({r.status_code}): {r.text}") # Logger
                except requests.exceptions.RequestException as e:
                    st.error(f"Erro de conex√£o ao salvar par√¢metro: {e}")
                    logger.error(f"Erro de conex√£o ao salvar par√¢metro {aba_selecionada}: {e}", exc_info=True) # Logger
                except Exception as e:
                    st.error(f"Erro inesperado ao salvar par√¢metro: {e}")
                    logger.error(f"Erro inesperado ao salvar par√¢metro {aba_selecionada}: {e}", exc_info=True) # Logger

if __name__ == "__main__":
    # Simula√ß√£o do st.session_state para fins de teste local
    if 'token' not in st.session_state: # Alterado de api_token para token
        st.session_state.token = "token_simulado_admin_params" 
    # client_id pode n√£o ser relevante para admin global, mas mantido para consist√™ncia se utils depender dele
    if 'client_id' not in st.session_state: # Alterado de id_cliente para client_id
        st.session_state.client_id = "admin_sem_cliente_especifico" 
    if 'user_info' not in st.session_state:
        # Adicionar 'roles' para simular verifica√ß√£o de admin, se implementada
        st.session_state.user_info = {"name": "Admin Teste", "username": "superadmin", "roles": ["admin"]}
    
    mostrar_pagina_admin_parametros_legais()
